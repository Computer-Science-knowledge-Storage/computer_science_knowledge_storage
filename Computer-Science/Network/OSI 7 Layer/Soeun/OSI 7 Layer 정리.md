## OSI 7 Layer 정리

### 1. 알아야 할 용어들

1. 프로토콜

- Q. 인터넷에 연결된 컴퓨터들은 엄청난 양의 데이터를 주고받는다. 허나, 각 나라마다 컴퓨터 만드는 회사도, 언어도 다른데 어떻게 이 데이터들을 주고받을까??

  A. 서로 다른 수많은 컴퓨터들이 인터넷에서 원활히 데이터를 주고받을 수 있는 것은 같은 프로토콜을 쓰기 때문

  프로토콜은 네트워크에 연결된 컴퓨터 간에 정보를 주고받을 때 지키기로 약속한 **규칙** (컴퓨터 간에 접속 방식, 주고받을 데이터 형식, 데이터 전송 방식 등을 약속함)

  예로 UN에서 세계 공용어로 영어를 포함한 6개 국어를 지정했듯, 서로 다른 컴퓨터 회사들이 프로토콜을 표준화시켜서 같은 목적으로 데이터를 주고받을 경우 동일한 프로토콜을 사용하게 함

  인터넷에서는 TCP/IP 프로토콜이 사실상의 표준임

  

### 2. OSI 7계층

- 통신이 일어나는 과정을 7단계로 정의한 국제 통신 표준 규약



#### 0. OSI 7계층 요약

| Layer Name      | Characteristic                                             |
| --------------- | ---------------------------------------------------------- |
| 7) Application  | - End User Layer <br />- Ex) HTTP, FTP, SSH, DNS           |
| 6) Presentation | - Syntax Layer                                             |
| 5) Session      | - Sync & Send to port <br />- Ex) API, Socket, WinSock     |
| 4) Transport    | - End-to-end connections <br />- Ex) TCP, UDP              |
| 3) Network      | - Packets <br />- Ex) IP, ICMP, IPSec, IGMP                |
| 2) Data Link    | - Frames <br />- Ex) Ethernet, Switch, Bridge              |
| 1) Physical     | - Physical Structure <br />- Ex) Wireless, Hubs, Repeaters |

=> 7계층 나누는 이유:

1) 다양한 네트워크 통신망이 혼재된 1980년대에 네트워크 유형에 무관하게 상호 통신이 가능하도록 만든 표준

2) 통신 과정을 단계별로 파악할 수 있으며, 특정 계층에 문제가 발생할 경우 해당 계층만 수정하면 됨

   => 용이성, 유지관리가 더 수월해짐 



#### 1. Physical Layer

- 디지털 데이터를 전기적 신호로 변환해 입출력을 담당하는 계층
- 전기적 신호 **0, 1로 이루어진 비트열을 연결된 모든 노드에게 전달**하는 계층 (데이터의 종류나 오류를 제어하지 않음)
- 주소 정보가 없어 목적지 인식이 안되며 전기적인 신호만을 연결된 노드에게 전달
- 두 장치 간 실제 접속, 절단과 같이 **기계적 특성에 대한 규칙**을 정의한 계층

=> 데이터 단위: 비트

=> 장비: 허브, 리피터

=> 프로토콜: RS-232C 등



#### 2. Data Link Layer

- 물리 계층에서의 **있는 그대로의 비트열 데이터를 신뢰할 수 있는 링크로 변환**

  => 신뢰할 수 있도록 변환: 흐름제어, 오류제어 등의 기능을 통해 데이터가 오류나 손실없이 전송됨을 보장한다는 뜻

  

  - 흐름제어:

    => 송수신자의 처리 속도 차이를 해결하기 위한 제어

     송신 측이 수신 측 데이터 처리 속도보다 훨씬 빠르게 데이터를 보내면 어떻게 될까? 
    
     수신측 buffer가 점점 길어지고, buffer가 다 차면 데이터를 저장할 수 없어 데이터가 손실될 것이다. 이를 방지하기 위해 수신 측에서는 송신 측에게 그만 보내거나, 천천히 보내달라는 등의 피드백을 보내는데 이것이 흐름제어다.

  

  - 오류제어:

    => 송신 측에서는 0, 1로 이루어진 비트를 보낼텐데, 이 전기적 신호들은 손실 등의 변화에 매우 취약하다. 따라서 수신 측은 이 전기적 신호에서 에러를 검출하며, 두 가지 방식이 대표적이다.

    

    1. FEC (Forward Error Correction)

       데이터 전송 과정에서 발생한 오류를 스스로 검출해 재전송 없이 수정하는 방식

       송신측에서 오류를 검출할 수 있는 확장 데이터를 추가해, 수신측에서 이를 활용해 스스로 오류를 검출하고 수정하는 방식

       연속적인 데이터 전송이 가능하나, 확장 데이터로 인해 전송 효율이 떨어짐

       

    2. BEC(Backward Error Correction)

       데이터 전송 과정에서 오류 발생 시 송신측에 재전송을 요구하는 방식

       1. Parity 방식: 1의 개수를 even으로 맞춰 보낼 지, odd로 맞춰 보낼 지 송수신 측이 약속하고 여분의 parity bit을 채운 것 (허나 single bit error와 같이 홀수 개의 오류만 검출 가능하며, 짝수 개의 오류는 검출하지 못함) 

       2. CRC 방식: 데이터에 오류가 발생했는지 확인하는 코드를 데이터 뒤에 확장 데이터로 붙여 보내는 방식
          - Checksum은 CRC의 한 종류임 (송신 측에서 모든 데이터를 더해 2의 보수로 만듦)

  

- **인접 노드 간 통신**하며, 목적지 노드에 도달하기 위해 **MAC 주소**를 설정함

  - MAC: xx:xx:xx:xx:xx:xx 형식의 6바이트로 전 세계에서 유일한, 고유한 물리적 주소임 (IP 주소는 동적으로 할당받는 논리적 주소라 고유한 값이 될 수 없으나, MAC은 고유한 물리적 주소임)

    

- 예로 스위치의 경우, MAC Address table을 갖고 있어 MAC 주소의 port에 연결된 노드에게만 packet을 전송함 (즉, 물리 계층과 다르게 특정 목적지로만 패킷을 전송함)



=> 데이터 단위: frame

=> 장비: 스위치, 브릿지, 랜카드 등

=> 프로토콜: HDLC, LAPB, PPP, LLC 등



#### 3. Network Layer

- 송신측에서 수신측까지 packet을 안전하게 전달하기 위한 계층으로, **종단 노드 간의 라우팅을 담당**

  - 라우팅: 라우팅 알고리즘에 의해 목적지까지 데이터를 전송하기 위한 **최적의 경로를 설정하고 패킷을 교환(포워딩)** 하는 것을 의미

    => 최종 목적지 노드까지 가기 위해선 노드에 대한 논리적 주소가 필요하며 이것이 바로 IP 주소



- IP 주소 vs MAC주소

  - IP 주소: 시작점과 끝점의 주소 (3계층에서 사용됨)
  - MAC 주소: 시작점과 끝점을 가기 위해선 사이사이 중간 노드들을 거쳐 데이터가 전달되어야 함. 이 중간 중간 서로 물리적으로 연결된 노드와 통신할 때 사용하는 주소 (2계층에서 사용됨)

  

   "즉, IP 주소간의 통신은 각 라우터에서 일어나는 MAC 주소와 MAC주소 통신의 연속적인 과정이라고 부를 수 있다."

    네트워크 통신 방식은 내가 옆 사람, 그 옆 사람, 또 그 옆 사람 이렇게 옆으로 계속 전달하는 방식으로 이루어져 있다. (네트워크에선 송수신자 사이에 수많은 서버와 라우터가 존재한다고 보면 된다.) 이렇게 나와 바로 붙은 옆 사람과의 통신을 보장하는 것이 data link layer 프로토콜이며, 이때 사용되는 주소가 MAC 주소이다. 일반적으로 우리는 본인의 IP, MAC 주소만 알고 목적지의 IP, MAC 주소는 모른다. 그럼 어떻게 통신이 이루어지는 걸까?

   예로 메일을 보내면 ~~@gmail.com 이렇게 도메인 주소로 메일을 발송하는데, 이 도메인 주소가 IP주소로 바뀌는 것이 DNS 프로토콜 (application layer)이다. 이후 IP 주소를 통해 MAC 주소를 알아내는 과정이 ARP (network layer)이다. 이렇게 찾아낸 수신자의 IP, MAC 주소와 송신자의 IP, MAC 주소로 table을 만들어 특정 IP로 보낼 때 마다 해당하는 MAC 주소로 데이터를 보내는 것이다. 

   그림을 그려보면,

  1. 수신자 도메인 => 수신자 IP 찾기 (7계층: DNS 사용)

  2. 수신자 IP => 수신자 MAC 찾기 (3계층: ARP 사용)

  3. 송신자 IP => 중간 노드 => 중간 노드 => 중간 노드 => 수신자 IP (2계층)

     이때 바로 옆 노드와의 통신에서 MAC 주소가 쓰인다. (즉, 바로 옆 노드간의 데이터 통신을 담당하는게 2계층이며, 이때 MAC 주소가 쓰인다! 3계층은 종단간의 데이터 통신을 담당하며, 이를 위해선 IP주소가 필요!)



- 프로토콜 세부 정보

  - IP (Internet Protocol)
    - 역할
      1. 지정한 IP 주소로 데이터 전달
      2. Packet이라는 통신 데이터 단위로 데이터 전달
    - 특징
      1. 비연결성: 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷을 전송함 (즉, 보내는 입장에서는 받는 대상의 서버 상태를 알지못하므로 그냥 패킷을 계속 보냄)
      2. 비신뢰성: 중간에 packet이 사라져도 데이터가 정확히 전달되었는지 확인하지 않는다. (즉, 패킷의 순서와 소실 여부 등을 보장하지 않는다)
      3. 프로그램 구분의 어려움: 같은 IP를 사용하는 서버에서 통신하는 어플리케이션이 여러개일 경우 어플리케이션을 구분하기 어려움 (IP 주소는 특정 기기의 주소이나, 해당 주소에서 여러 어플리케이션을 사용하면 각각을 구분하기 어려움)
  
  
  
  - ARP
    - 역할
      1. 같은 네트워크 대역에서 통신을 하기 위해 필요한 MAC 주소를 IP주소를 통해 알아내는 프로토콜



=> 데이터 단위: packet

=> 장비: 라우터, 스위치

=> 프로토콜: IP, ARP, RARP, ICMP, IGMP 등



#### 4. Transport Layer

- 세션을 맺고 있는 **두 사용자 간의 신뢰성 있는 데이터 전송을 위해 종단 프로세스 간 전송**을 담당하는 계층

  - 종단 간 전송: **송신 컴퓨터의 프로세스에서 수신 컴퓨터의 프로세스로의 전달**

    => 목적지 프로세스를 찾기 위해선 **프로세스를 식별하기 위한 논리적 주소인 Port Address 필요**

    => 컴퓨터 주소를 IP로 특정 짓는다면, 그 컴퓨터내의 프로세스를 특정 짓는게 바로 Port 번호 (Socket Address는 IP+Port)

    

    - 수신자 혹은 송신자 내에서 프로세스 찾는 건 4계층

    - 송수신 IP 주소 간의 길을 찾는 라우팅은 3계층

    - 송신자에서 수신자까지 찾아가기 위해 바로 옆 노드간의 통신은 2계층

      위와 같이 정리할 수 있다. 

      

    송신자 프로세스 - | 송신자 IP - 중간 노드 - 중간 노드 - 중간 노드 - 수신자 IP | - 수신자 프로세스

​										4계층		 3계층		2계층		2계층		3계층		4계층



- 프로토콜 세부 정보

  - TCP (Transmission Control Protocol)

    => 신뢰적이고 연결지향적 서비스 제공

     3계층의 IP는 호스트간의 논리적 통신을 제공하나, 어떠한 보장도 하지 않는다. 즉, segment의 전달, segment내의 순서와 무결성 그 어떠한 것도 보장하지 않음

     이 경우 packet이 손실 / packet의 순서가 바뀌는 문제 / network가 혼잡한 문제 / receiver가 overload되는 문제 등이 발생할 수 있음

     따라서, TCP는 연결제어 / 오류제어 / 흐름제어 / 혼잡제어 서비스를 추가적으로 제거하여 수신하는 프로세스에게 데이터 내의 순서, 무결성을 보장하며 연결 폭주 등을 방지함 (단, 이를 위해 UDP에 비해 더 느리고 복잡하나 보다 신뢰성 있는 프로그램이 될 수 있음)

  

  - UDP (User Datagram Protocol)

    => 어플리케이션 간에 비신뢰적이고, 비연결형 서비스를 제공

     IP와 같이 비신뢰적인 서비스로, 두 프로세스 간의 데이터 전달과 오류 검출 두 가지 기능만 수행함

     주로 빠른 속도로 데이터를 전송해야 할 때 사용하는 프로토콜



=> 데이터 단위: segment (TCP) / datagram (UDP)

=> 장비: 게이트웨이

=> 프로토콜: TCP, UDP



#### 5. Session Layer

- 어플리케이션 간의 논리적 연결인 세션의 생성, 관리, 종료를 담당하는 계층
- 대화제어를 담당하며, 송수신간의 대화 동기를 위해 전송하는 정보의 일부분에 동기점을 두어 수신 상태를 체크함
- TCP/IP 세션을 만들고 없애는 역할을 수행

=> 프로토콜: API, Socket 등



#### 6. Presentation Layer

- 송수신자가 공통으로 이해할 수 있도록 데이터 표현방식을 변경하는 계층

- 수행하는 기능

  - 코드변환

  - 데이터 암복호화
  - 압축
  - 구문검색
  - 문맥관리
  - 형식변환



#### 7. Application Layer

- 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행함

- 프로토콜 세부 정보
  - HTTP
  
    - 역할
  
      1. 초기에는 웹 브라우저와 웹 서버간의 통신을 위해 설계되었으나 최근에는 모바일 어플리케이션 등 다른 목적으로도 사용되는 어플리케이션 계층 프로토콜
  
    - 동작 방식
  
      1. 클라이언트: 브라우저를 통해 어떤 서비스를 URI를 통해 서버에 **요청**
      2. 서버: 해당 요청에 대한 결과를 **응답**
  
    - 메서드:
  
      GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS
  
  
  
  - DNS (Domain Name System)
  
    - 도메인: 
  
      원래 지정된 인터넷 접속 주소를 다른 이름으로 바꾸어 주는 주소
  
      => 원래는 IP 주소로 접근해야 하나, 기억하기 어려우니 www.이름.com 이런식으로 바꾸어주는 것
  
    - 역할:
  
      1. 위에서 말한대로 원래의 IP 주소를 기억하기 쉬운 도메인으로 바꿈
      2. 도메인을 다시 IP 주소로 바꿈
  
      => 즉, IP와 도메인을 연결해주는 시스템 (DNS서버==Name서버==각 도메인들을 DNS와 연결해주는 서버)
  
    - 동작 방식:
  
      1. 주소.com 입력
      2. 주소.com을 갖고 있는 네임 서버에 접속
      3. IP 주소 확인 및 IP 주소를 가진 서버로 접속
      4. 연결된 브라우저 실행

=> 프로토콜: HTTP, FTP, SSH, DNS 등



#### 통신 전체 단계 한번에 톺아보기

- application: E-mail 프로그램을 통해 이메일 작성

- presentation: 공통된 표현 형식으로 데이터를 변환, 암호화, 압축을 수행
- session: 데이터의 동기화를 위해 일정 길이마다 sync를 삽입해 transport 계층으로 데이터를 전달함
- transport: 발신자와 목적지의 주소를 지정, 연결 방식, 흐름제어, 오류제어를 함. 이후 데이터를 segment 단위로 나눔
- network: 라우팅에 필요한 IP 주소를 설정하고 Packet에 라우팅 정보 삽입함
- data link: frame단위로 데이터를 나눈 후 MAC 주소를 설정함. 양 끝단의 속도차이를 원활하게 하기 위해 흐름제어를 함. 또한 데이터의 오류를 방지하기 위해 CRC나 checksum으로 오류제어를 진행함
- physical: 전송 매체로 일반 케이블, 광케이블 등을 결정함. 전송 방식과 데이터를 회선으로 보내기 위해 전기적 변환을 담당함



#### Reference

https://liveyourit.tistory.com/186

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Network/OSI%207%20%EA%B3%84%EC%B8%B5.md

https://velog.io/@dyllis/OSI-7%EA%B3%84%EC%B8%B5-%EC%A0%95%EB%A6%AC

https://jungeun960.tistory.com/181

https://tyeolrik.github.io/network/2017/02/14/Networking-4-Data-Link-Layer.html

https://wookiist.dev/54

https://nack1400.tistory.com/21